"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ttsCommand = void 0;
const fs_1 = require("fs");
const commander_1 = __importDefault(require("commander"));
const dasha = __importStar(require("@dasha.ai/sdk"));
exports.ttsCommand = commander_1.default.createCommand();
exports.ttsCommand.name("tts").description("text-to-speech synthesis");
exports.ttsCommand
    .command("synthesize <text>")
    .alias("synth")
    .requiredOption("-o --output <filename>")
    .option("--provider-name <name>", "TTS provider name", "dasha")
    .option("--lang <code>", "", "en-US")
    .option("--speaker <name>", "", "default")
    .option("--emotion <emotion>", "", "neutral")
    .option("--speed <value>", "", (value) => parseFloat(value), 1.0)
    .option("--variation <value>", "", (value) => parseInt(value), 0)
    .action(async (text, options) => {
    const { output, providerName, ...voice } = options;
    const data = await dasha.tts.synthesize(text, voice, { providerName });
    await fs_1.promises.writeFile(output, data);
});
const speakerCommand = exports.ttsCommand.command("speaker").description("Manage custom speakers");
speakerCommand
    .command("list")
    .description("List of created speakers")
    .action(async () => {
    const speakers = await dasha.tts.getCustomSpeakers();
    console.log(JSON.stringify(speakers, undefined, 2));
});
speakerCommand
    .command("add <name>")
    .alias("clone")
    .requiredOption("-f --file <filename>", "Path to file with voice example")
    .description("Create speaker cloning voice from wav or mp3 file")
    .action(async (name, options) => {
    const content = await fs_1.promises.readFile(options.file);
    const speaker = await dasha.tts.addOrUpdateCustomSpeakerByName(name, content);
    console.log(JSON.stringify(speaker, undefined, 2));
    console.log(`Now you can run 'dasha tts synth --speaker "${name}" "Hi, this is my voice" -o myVoice.mp3 --provider-name voice-cloning'`);
});
speakerCommand
    .command("delete <name>")
    .description("Delete cloned speaker")
    .action(async (name) => {
    await dasha.tts.deleteCustomSpeakerByName(name);
    console.log("Deleted");
});
speakerCommand
    .command("get <name>")
    .description("Get cloned speaker information")
    .action(async (name) => {
    const speaker = await dasha.tts.getCustomSpeakerByName(name);
    console.log(JSON.stringify(speaker, undefined, 2));
});
//# sourceMappingURL=tts.js.map