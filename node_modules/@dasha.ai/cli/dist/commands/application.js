"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applicationCommand = exports.argsParser = void 0;
const dasha = __importStar(require("@dasha.ai/sdk"));
const commander_1 = __importDefault(require("commander"));
const fs = __importStar(require("fs"));
const mime = __importStar(require("mime-types"));
const argsParser = function (args) {
    const result = {};
    if (args == undefined)
        return result;
    for (const arg of args) {
        const index = arg.indexOf("=");
        if (index > 0) {
            result[arg.substr(0, index)] = arg.substr(index + 1);
        }
        else {
            throw new Error(`Unexpected arg: ${arg}. Expected ${arg}=value`);
        }
    }
    return result;
};
exports.argsParser = argsParser;
exports.applicationCommand = commander_1.default.createCommand();
exports.applicationCommand.name("app").description("application management");
exports.applicationCommand
    .command("deploy [path]")
    .description("deploy an application to the platform")
    .action(async (path) => {
    const app = await dasha.deploy(path !== null && path !== void 0 ? path : "./");
    console.log(`Application deployed successfully`);
    console.log(`ApplicationId: ${app.applicationId}`);
    console.log(`Server: ${app.account.server}`);
    console.log(`Input schema: ${JSON.stringify(app.inputSchema)}`);
    console.log(`Output schema: ${JSON.stringify(app.outputSchema)}`);
    await app.dispose();
});
exports.applicationCommand
    .command("download <appId> [path]")
    .description("Download the application package")
    .action(async (appId, path) => {
    const appPackage = await dasha.applications.getApplicationPackageById(appId);
    path = path !== null && path !== void 0 ? path : `${appId}.${mime.extension(appPackage.contentType)}`;
    console.log(`Saving to ${path}`);
    await fs.promises.writeFile(path, appPackage.content, "binary");
});
exports.applicationCommand
    .command("info <appId>")
    .description("Get the application information")
    .action(async (appId) => {
    const app = await dasha.applications.getApplicationById(appId);
    console.log(JSON.stringify(app, undefined, 2));
});
exports.applicationCommand
    .command("list")
    .description("List of deployed applications")
    .action(async () => {
    const apps = await dasha.applications.getApplications();
    console.log(JSON.stringify(apps, undefined, 2));
});
exports.applicationCommand
    .command("run [path]")
    .option("--chat", "connect via chat")
    .option("--sip [sipconfig]", "connect via sip")
    .option("--tts <ttsconfig>", "tts config", "default")
    .option("--stt <sttconfig>", "stt config", "default")
    .option("--noiseVolume <noiseVolume>", "Noise volume: 0..1", (value) => parseFloat(value))
    .option("--interlocutorPauseDelay <interlocutorPauseDelay>", "Length of expected pause in seconds at the end of human speech", (value) => parseFloat(value))
    .option("--debug-log", "Show debug logs")
    .option("--input <input...>", "Input arguments in form arg1=value1 arg2=value2 and etc")
    .option("--inputFile <inputFile>", "Read input arguments from file")
    .description("run single conversation")
    .action(async (path, options) => {
    if (!options.chat && options.sip === undefined) {
        throw new Error("--chat or --sip required");
    }
    let input = exports.argsParser(options.input);
    if (options.inputFile !== undefined)
        input = { ...JSON.parse(await fs.promises.readFile(options.inputFile, "utf-8")), ...input };
    console.log(input);
    const app = await dasha.deploy(path !== null && path !== void 0 ? path : "./");
    await app.start();
    const conversation = app.createConversation(input);
    let channel;
    conversation.audio = {
        tts: options.tts,
        stt: options.stt,
        noiseVolume: options.noiseVolume,
        vadDelay: options.interlocutorPauseDelay,
    };
    if (options.sip !== undefined) {
        conversation.sip.config = options.sip === true ? "default" : options.sip;
        channel = "audio";
    }
    else if (options.chat) {
        channel = "text";
        await dasha.chat.createConsoleChat(conversation);
    }
    if (options.debugLog) {
        conversation.on("debugLog", (event) => console.log(JSON.stringify(event)));
    }
    if (!options.chat) {
        conversation.on("transcription", console.log);
    }
    const result = await conversation.execute({ channel });
    console.log(result.output);
    await app.stop();
    app.dispose();
});
//# sourceMappingURL=application.js.map