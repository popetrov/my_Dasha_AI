"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NluService = void 0;
const lodash_1 = require("lodash");
const account_1 = require("./account");
const log_1 = require("./log");
const errors_1 = require("./errors");
const grpc = __importStar(require("./grpc-api"));
/**
 * Service for standalone using and testing NLU.
 * Provides the API for training custom datasets, using pretrained skills and performing recognition requests.
 */
class NluService {
    constructor(options) {
        /**
         * Mapping of skill names to information about skills used for recognition
         */
        this.skillInfo = {};
        this.closed = false;
        this.options = options;
    }
    /**
     * Create instance of NLU service
     * Optionally train dataset @param nluContent with language @param language if provided
     * @param nluContent - Intents file content
     * @param language - BCP 47 language tag denoting language of dataset (e. g. "en-US"). @see {@link https://en.wikipedia.org/wiki/IETF_language_tag}
     * @param options - Launch options
     */
    static async create(nluContent, language, options = {}) {
        var _a;
        const nluClient = new NluService(options);
        nluClient.account = (_a = options.account) !== null && _a !== void 0 ? _a : (await account_1._getEffectiveAccount({ _log: log_1.log }));
        nluClient.log = log_1.log.child({ account: account_1.anonymizeAccount(nluClient.account) });
        nluClient.client = await grpc.createNluServiceClient(nluClient.account, nluClient.log);
        if (nluContent !== undefined) {
            if (language === undefined)
                throw new errors_1.NluServiceError("Language must be provided to train nluContent");
            await nluClient.train(nluContent, language);
        }
        else if (language !== undefined)
            nluClient.log.warn("Provided language parameter is ignored since no nluContent was provided");
        return nluClient;
    }
    /**
     * Close nlu service if it is alive
     */
    close() {
        if (this.closed)
            return;
        this.closed = true;
        this.client.close();
    }
    /**
     * Check if nlu service is closed
     * @returns true if service is closed, false otherwise
     */
    get isClosed() {
        return this.closed;
    }
    /**
     * Process text in nlu service and return recognition result
     * @param text - Text to be recognized
     * @returns recognition result
     */
    async recognize(text) {
        if (this.closed) {
            throw new errors_1.NluServiceError(`NLU service is already closed`);
        }
        this.log.debug(`Recognizing text '${text.length > 20 ? text.slice(0, 20) + "..." : text}'...`);
        const languageToSkills = lodash_1.groupBy(Object.values(this.skillInfo), (skillInfo) => skillInfo.language);
        const results = { v1: {} };
        for (const lang of Object.keys(languageToSkills)) {
            this.log.debug(`Using skills ${JSON.stringify(languageToSkills[lang].map(({ id }) => id))} of language ${lang}`);
            const recognitionResponse = await this.client.recognize(languageToSkills[lang].map(({ id }) => id), lang, text);
            const convertedResult = NluService.convertRecognitionResult(recognitionResponse);
            for (const version of Object.keys(convertedResult)) {
                if (version === "v1") {
                    results[version][lang] = convertedResult[version];
                }
                else
                    throw new errors_1.NluServiceError(`Could not save recognition result: unknown message format version '${version}'`);
            }
        }
        this.log.debug("Recognition complete");
        return results;
    }
    /**
     * Check if provided skills are available and use them in further recognitions
     * @param skills
     */
    async loadSkills(skills) {
        const languageToRequestedSkills = lodash_1.groupBy(skills, (skillInfo) => skillInfo.language);
        const notFoundIds = [];
        for (const lang of Object.keys(languageToRequestedSkills)) {
            const requiredIds = languageToRequestedSkills[lang].map(({ id }) => id);
            const availableIds = await this.getAvailableSkills(lang);
            const foundIds = lodash_1.intersection(requiredIds, availableIds);
            notFoundIds.push(...lodash_1.difference(requiredIds, foundIds));
        }
        if (notFoundIds.length > 0)
            throw new errors_1.NluServiceError(`Could not load skills: skills ${JSON.stringify(notFoundIds)} are not available.`);
        this.log.debug(`Skills ${JSON.stringify(languageToRequestedSkills)} are available.`);
        for (const skill of skills) {
            Object.assign(this.skillInfo, {
                [skill.id]: skill,
            });
        }
    }
    async train(contentOrPath, language) {
        const fs = await Promise.resolve().then(() => __importStar(require("fs"))).catch(() => null);
        if (fs === null) {
            throw new errors_1.NotImplementedError("this function is only implemented in Node.js");
        }
        if (this.closed) {
            throw new errors_1.NluServiceError(`NLU service is already closed`);
        }
        let nluContent;
        if (typeof contentOrPath === "string") {
            // first argument is path
            const nluDatasetPath = contentOrPath;
            try {
                nluContent = JSON.parse(await fs.promises.readFile(nluDatasetPath, "utf-8"));
            }
            catch (e) {
                throw new errors_1.NluServiceError(`Could not parse dataset file on path '${nluDatasetPath}': ${e.message}`);
            }
        }
        else {
            nluContent = contentOrPath;
        }
        const customSkillId = await this.trainInner(nluContent, language);
        Object.assign(this.skillInfo, {
            [customSkillId]: { id: customSkillId, language: language },
        });
        return customSkillId;
    }
    async trainInner(nluContent, language) {
        return new Promise((resolve, reject) => {
            this.log.info(`Training NLU custom skill...`);
            const stream = this.client.train(nluContent, language);
            stream.on("error", (error) => {
                stream.cancel();
                reject(error);
            });
            stream.on("processing", (percent, stageDescription, stageScopeList, extraInfoJson) => {
                this.log.info(`Training skill in progress. Stage: ${stageDescription}\n\tCompletion: ${percent}%`);
            });
            stream.on("ready", (skillId) => {
                stream.removeAllListeners();
                if (!skillId) {
                    reject(new errors_1.NluServiceError("NLU service returned empty skill"));
                    return;
                }
                this.log.info(`Training completed, loaded skill: ${skillId}`);
                resolve(skillId);
            });
        });
    }
    async getAvailableSkills(language) {
        return NluService.convertAvailableSkillsResult(await this.client.getAvailableSkills(language));
    }
    static convertRecognitionResult(recognitionResponse) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const result = {
            v1: {
                data: (_b = (_a = recognitionResponse.v1) === null || _a === void 0 ? void 0 : _a.dataRecognitionsList.map((dataRec) => {
                    return {
                        type: "data",
                        data: dataRec.dataMap,
                        dataName: dataRec.dataName,
                        skill: dataRec.skill,
                        confidence: dataRec.confidence,
                    };
                })) !== null && _b !== void 0 ? _b : [],
                intents: (_d = (_c = recognitionResponse.v1) === null || _c === void 0 ? void 0 : _c.intentRecognitionsList.map((intentRec) => {
                    return {
                        type: "intent",
                        intent: intentRec.intent,
                        state: intentRec.state,
                        sentenceType: intentRec.sentenceType,
                        skill: intentRec.skill,
                        confidence: intentRec.confidence,
                    };
                })) !== null && _d !== void 0 ? _d : [],
                sentenceType: {
                    type: "sentenceType",
                    sentenceType: (_f = (_e = recognitionResponse.v1) === null || _e === void 0 ? void 0 : _e.sentenceType) === null || _f === void 0 ? void 0 : _f.sentenceType,
                    confidence: (_j = (_h = (_g = recognitionResponse.v1) === null || _g === void 0 ? void 0 : _g.sentenceType) === null || _h === void 0 ? void 0 : _h.confidence) !== null && _j !== void 0 ? _j : 0,
                },
            },
        };
        return result;
    }
    static convertAvailableSkillsResult(availableSkillsResponseAsObject) {
        return availableSkillsResponseAsObject.availableSkillsList;
    }
}
exports.NluService = NluService;
//# sourceMappingURL=nlu.js.map